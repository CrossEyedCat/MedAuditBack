# Техническое задание на разработку бэкенд-части системы MediAudit

## 1. Введение

### 1.1. Наименование проекта
MediAudit — система для автоматического аудита медицинской документации с использованием NLP.

### 1.2. Цель проекта
Создать безопасное, масштабируемое и производительное бэкенд-приложение, которое обеспечивает работу с пользователями, обработку медицинских документов, интеграцию с NLP-сервисом для анализа и предоставление результатов аудита.

---

## 2. Общие технические требования

### 2.1. Технологический стек

- **Язык**: Python 3.9+
- **Фреймворк**: FastAPI (предпочтительно для асинхронности и современного подхода) или Django 4.x+ (с DRF)
- **База данных**: PostgreSQL 12+
- **Кеширование и брокер сообщений**: Redis
- **Очереди задач**: Celery
- **Хранилище файлов**: Локальная файловая система (на этапе разработки) с возможностью миграции на AWS S3 или совместимый объектный сторадж
- **Контейнеризация**: Docker, Docker Compose (для упрощения развертывания и разработки)

### 2.2. Стандарты кодирования

- Соблюдение PEP 8
- Использование type hints
- Написание docstrings для всех публичных методов и классов
- Покрытие кода unit-тестами (не менее 80%)

---

## 3. Детализация функциональных требований

### Этап 1: Базовая инфраструктура и безопасность

#### Задача 1.1: Настройка серверного окружения и каркаса приложения

- Создать Docker-окружение для разработки (PostgreSQL, Redis)
- Инициализировать проект на FastAPI/Django
- Настроить подключение к БД, миграции (Alembic для FastAPI, встроенные для Django)

#### Задача 1.2: Система аутентификации и авторизации

- Реализовать регистрацию и вход по JWT (access/refresh tokens)

---

### Этап 2: API для работы с документами и интеграция с NLP

#### Задача 2.1: Модуль загрузки и хранения документов

- Создать endpoint `POST /api/v1/documents/upload` для загрузки файлов
- Реализовать валидацию:
  - Типы файлов (PDF, DOCX, JPEG, PNG)
  - Максимальный размер (например, 50 МБ)
- В БД сохранять метаданные:
  - Оригинальное название
  - Размер
  - MIME-тип
  - Хэш (для проверки дубликатов)
  - Статус обработки

#### Задача 2.2: Интеграция с NLP-сервисом

- Настроить Celery + Redis для обработки фоновых задач
- Создать асинхронную задачу `process_document_with_nlp(document_id: str)`

В задаче:
1. Отправлять документ (или путь к нему) на NLP-сервис по REST
2. Обрабатывать ответы NLP-сервиса (успех, ошибка, таймаут)
3. При успехе — парсить ответ и сохранять результат в БД
4. При ошибке — делать повторные попытки с экспоненциальной задержкой

- Создать callback endpoint `POST /api/v1/nlp/callback`, который NLP-сервис будет вызывать для асинхронного возврата результата (альтернатива опросу)

---

### Этап 3: Бизнес-логика и API для отчетов

#### Задача 3.1: Проектирование и реализация моделей данных

Важные поля:

- **AuditReport**:
  - `document_id` (FK)
  - `status` (pending, processing, completed, failed)
  - `created_at`
  - `completed_at`

- **Violation**:
  - `code`
  - `description`
  - `risk_level` (low, medium, high, critical)
  - `regulation_reference`

#### Задача 3.2: API для работы с отчетами об аудите

- `GET /api/v1/reports/`: Список отчетов с пагинацией, фильтрацией (по статусу, дате, типу нарушения) и сортировкой
- `GET /api/v1/reports/{id}`: Детальная информация об отчете, включая все выявленные нарушения
- `POST /api/v1/reports/generate`: Запуск процесса анализа документа (создает запись в AuditReport и ставит задачу в Celery)
- `GET /api/v1/reports/{id}/export`: Генерация PDF-отчета (интеграция с библиотекой типа WeasyPrint или ReportLab)

---

### Этап 4: Интеграция и финальные работы

#### Задача 4.1: Повышение безопасности системы

- Добавить валидацию и санитизацию всех входящих данных (Pydantic-схемы для FastAPI)
- Настроить CORS для домена фронтенд-приложения
- Реализовать подробное логирование всех критичных действий (загрузка документа, вход в систему, ошибки)

#### Задача 4.2: Интеграция с фронтендом и тестирование

- Согласовать и строго соблюдать формат всех JSON-ответов (успех, ошибка) с фронтенд-командой
- Написать unit- и integration-тесты для ключевых модулей (аутентификация, загрузка файлов, задачи Celery)

---

## 4. Взаимодействие с NLP

### 4.1. Формат запроса к NLP-сервису (от Бэкенда)

```json
{
  "request_id": "uuid_генерируемый_бэкендом",
  "document_id": "uuid_документа_в_бд",
  "file_url": "https://storage.example.com/path/to/doc.pdf",
  "callback_url": "https://backend.medyaudit.ru/api/v1/nlp/callback"
}
```

**Примечание**: `file_url` может быть URL или base64, но URL предпочтительнее.

### 4.2. Формат ответа от NLP-сервиса (на Callback URL)

```json
{
  "request_id": "uuid_генерируемый_бэкендом",
  "document_id": "uuid_документа_в_бд",
  "status": "success",
  "analysis_result": {
    "violations": [
      {
        "code": "2.13",
        "description": "Отсутствие информированного согласия",
        "risk_level": "high",
        "regulation": "Ст. 20 ФЗ-323",
        "context": "В разделе 'Согласие на обработку данных' отсутствует подпись пациента.",
        "offset_start": 1250,
        "offset_end": 1300
      }
    ],
    "summary": {
      "total_risks": 180000,
      "critical_count": 2,
      "compliance_score": 4.0
    }
  },
  "error_message": "Текст ошибки, если status='error'"
}
```

**Статусы**:
- `"success"` — успешная обработка
- `"error"` — ошибка при обработке

**Поля violations**:
- `code` — код нарушения
- `description` — описание нарушения
- `risk_level` — уровень риска (low, medium, high, critical)
- `regulation` — ссылка на нормативный документ
- `context` — контекст нарушения в документе
- `offset_start` — начало позиции в документе
- `offset_end` — конец позиции в документе

**Поля summary**:
- `total_risks` — общее количество рисков
- `critical_count` — количество критических нарушений
- `compliance_score` — оценка соответствия (число)

---

## 5. Критерии приемки (Definition of Done)

1. Код написан, протестирован (unit-тесты) и проходит код-ревью
2. Все API endpoints корректно работают и возвращают согласованные HTTP-статусы и форматы JSON
3. Интеграция с NLP-сервисом стабильно работает в фоновом режиме, обрабатывая успешные и ошибочные сценарии
4. Система развернута в тестовом окружении и написана инструкция тестирования для фронтенда
5. Сгенерирована актуальная документация API через Swagger
6. Проведено нагрузочное тестирование ключевых endpoints (загрузка файла, генерация отчета)

---

## 6. Дополнительные требования

### 6.1. Безопасность

- Все пароли должны храниться в хешированном виде
- JWT токены должны иметь ограниченное время жизни
- Реализовать механизм refresh токенов
- Валидация всех входящих данных
- Защита от SQL-инъекций (использование ORM)
- Защита от XSS (санитизация данных)
- Настройка CORS для ограничения доступа

### 6.2. Производительность

- Оптимизация запросов к БД (индексы, eager loading)
- Кеширование часто запрашиваемых данных
- Асинхронная обработка тяжелых операций через Celery
- Оптимизация работы с файлами

### 6.3. Масштабируемость

- Архитектура должна позволять горизонтальное масштабирование
- Использование очередей задач для распределения нагрузки
- Возможность миграции на облачное хранилище файлов

### 6.4. Мониторинг и логирование

- Структурированное логирование всех операций
- Логирование ошибок с контекстом
- Мониторинг производительности ключевых операций

---

## 7. Структура API Endpoints

### 7.1. Аутентификация

- `POST /api/v1/auth/register` — регистрация пользователя
- `POST /api/v1/auth/login` — вход пользователя
- `POST /api/v1/auth/refresh` — обновление токенов
- `POST /api/v1/auth/logout` — выход пользователя

### 7.2. Документы

- `POST /api/v1/documents/upload` — загрузка документа
- `GET /api/v1/documents/` — список документов пользователя
- `GET /api/v1/documents/{id}` — информация о документе
- `GET /api/v1/documents/{id}/download` — скачивание документа
- `DELETE /api/v1/documents/{id}` — удаление документа

### 7.3. Отчеты

- `POST /api/v1/reports/generate` — запуск анализа документа
- `GET /api/v1/reports/` — список отчетов (с фильтрацией и пагинацией)
- `GET /api/v1/reports/{id}` — детальная информация об отчете
- `GET /api/v1/reports/{id}/export` — экспорт отчета в PDF
- `GET /api/v1/reports/{id}/violations` — список нарушений отчета

### 7.4. NLP Callback

- `POST /api/v1/nlp/callback` — callback от NLP-сервиса

---

## 8. Модели данных

### 8.1. User (Пользователь)

- `id` — UUID, первичный ключ
- `email` — строка, уникальный, обязательное
- `password_hash` — строка, обязательное
- `created_at` — дата/время создания
- `updated_at` — дата/время обновления
- `is_active` — булево, по умолчанию True

### 8.2. Document (Документ)

- `id` — UUID, первичный ключ
- `user_id` — UUID, внешний ключ на User
- `original_filename` — строка, оригинальное имя файла
- `stored_filename` — строка, имя файла в хранилище
- `file_size` — целое число, размер файла в байтах
- `mime_type` — строка, MIME-тип файла
- `file_hash` — строка, SHA-256 хеш файла
- `status` — строка, статус обработки (pending, processing, completed, failed)
- `created_at` — дата/время создания
- `updated_at` — дата/время обновления

### 8.3. AuditReport (Отчет об аудите)

- `id` — UUID, первичный ключ
- `document_id` — UUID, внешний ключ на Document
- `request_id` — UUID, уникальный идентификатор запроса к NLP
- `status` — строка, статус (pending, processing, completed, failed)
- `created_at` — дата/время создания
- `completed_at` — дата/время завершения (опционально)
- `error_message` — строка, сообщение об ошибке (опционально)

### 8.4. Violation (Нарушение)

- `id` — UUID, первичный ключ
- `audit_report_id` — UUID, внешний ключ на AuditReport
- `code` — строка, код нарушения
- `description` — текст, описание нарушения
- `risk_level` — строка, уровень риска (low, medium, high, critical)
- `regulation_reference` — строка, ссылка на нормативный документ
- `context` — текст, контекст нарушения в документе
- `offset_start` — целое число, начало позиции
- `offset_end` — целое число, конец позиции

### 8.5. AnalysisSummary (Сводка анализа)

- `id` — UUID, первичный ключ
- `audit_report_id` — UUID, внешний ключ на AuditReport
- `total_risks` — целое число, общее количество рисков
- `critical_count` — целое число, количество критических нарушений
- `high_count` — целое число, количество нарушений высокого уровня
- `medium_count` — целое число, количество нарушений среднего уровня
- `low_count` — целое число, количество нарушений низкого уровня
- `compliance_score` — число с плавающей точкой, оценка соответствия

---

## 9. Обработка ошибок

### 9.1. Стандартный формат ошибки

```json
{
  "error": {
    "code": "ERROR_CODE",
    "message": "Человекочитаемое сообщение об ошибке",
    "details": {}
  }
}
```

### 9.2. HTTP статус коды

- `200 OK` — успешный запрос
- `201 Created` — ресурс успешно создан
- `400 Bad Request` — неверный запрос (валидация)
- `401 Unauthorized` — требуется аутентификация
- `403 Forbidden` — нет прав доступа
- `404 Not Found` — ресурс не найден
- `422 Unprocessable Entity` — ошибка валидации данных
- `500 Internal Server Error` — внутренняя ошибка сервера
- `503 Service Unavailable` — сервис временно недоступен

---

## 10. Переменные окружения

### 10.1. Обязательные переменные

- `DATABASE_URL` — строка подключения к PostgreSQL
- `REDIS_URL` — строка подключения к Redis
- `SECRET_KEY` — секретный ключ для JWT
- `NLP_SERVICE_URL` — URL NLP-сервиса
- `NLP_SERVICE_API_KEY` — API ключ для NLP-сервиса (если требуется)
- `BACKEND_URL` — URL бэкенд-приложения (для callback)

### 10.2. Опциональные переменные

- `DEBUG` — режим отладки (True/False)
- `LOG_LEVEL` — уровень логирования (DEBUG, INFO, WARNING, ERROR)
- `FILE_STORAGE_PATH` — путь к хранилищу файлов
- `MAX_FILE_SIZE` — максимальный размер файла в байтах
- `ALLOWED_FILE_TYPES` — разрешенные типы файлов (через запятую)

---

## 11. Документация

### 11.1. API Документация

- Автоматическая генерация через Swagger/OpenAPI
- Описание всех endpoints
- Примеры запросов и ответов
- Описание схем данных

### 11.2. Техническая документация

- README.md с инструкциями по установке и запуску
- Описание архитектуры системы
- Инструкция по развертыванию
- Инструкция для тестирования (для фронтенд-команды)

---

## 12. Тестирование

### 12.1. Unit-тесты

- Покрытие не менее 80%
- Тестирование всех сервисных слоев
- Тестирование утилит и хелперов
- Mock внешних зависимостей (NLP-сервис, БД)

### 12.2. Integration-тесты

- Тестирование полного цикла обработки документа
- Тестирование интеграции с NLP через callback
- Тестирование аутентификации и авторизации
- Тестирование генерации PDF

### 12.3. Нагрузочное тестирование

- Тестирование загрузки файлов под нагрузкой
- Тестирование генерации отчетов
- Тестирование списков с пагинацией
- Определение узких мест производительности

---

## Примечания

- Все даты и время должны храниться в UTC
- Все UUID должны быть версии 4
- Все текстовые поля должны поддерживать UTF-8
- Рекомендуется использовать транзакции БД для критичных операций
- Необходимо предусмотреть механизм отката изменений при ошибках


